<head>
<script oldsrc="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"
  src="jquery.min.js"
></script>
<link type="text/css"
  href="css/themename/jquery-ui-1.8.23.custom.css"
  rel="Stylesheet" />     
<script
  oldsrc="jquery-ui-1.8.23.custom.min.js"
  oldsrc="https://ajax.googleapis.com/ajax/libs/jqueryui/1.8.12/jquery-ui.js"
  src="jquery-ui.js"
  >
</script>

<style>
text {
  fill: black;
  stroke: none;
  font-family: Verdana, sans-serif;
  font-size: 12px;
}
text.leaf {
  font-size: 10px;
}
text.interior {
  text-anchor: middle;
}
path {
    fill: none;
    stroke: grey;
    stroke-width: 0.7px;
}
</style>
<script>
// http://ejohn.org/blog/fast-javascript-maxmin/
Array.max = function( array ){
    return Math.max.apply( Math, array );
};
Array.min = function( array ){
    return Math.min.apply( Math, array );
};

$(function() {
u='http://localhost:8000/';
u='data/ncbi.json'
u='data/prune.json'
n='data/name.json'
x='data/extinct.json'
r='data/rank.json'
var BB = 2; // Border within each box.
$.getJSON(u, function(data){
    alltree = data;
    console.log('loaded', u);
    alltree = stripINT(alltree)
    $.getJSON(x, function(data){
        extinct = data
        $.getJSON(n, function(data){
            ncbiname = data;
            console.log('loaded', n);
            console.log(ncbiname);
            $.getJSON(r, function(data){
                rank = data
                doStuff()
            })
        })
    })
})
doStuff = function()
{
    // 40674 mammals (class)
    //   32525 Theria
    //     9347 placentals
    //       314145
    //         91561
    //           9721 Cetacea
    //         33554
    //           379583
    //             9681 Felidae (family)
    //               338152 Felinae
    //               ...
    //       314146
    //         314147
    //           9899 Rodentia (order)
    //             33553
    //               337687
    //                 10066 Muridae (family)
    //                   39107 Murinae
    var target = '40674'
    tree = search(alltree, target)
    tree = remove_unwanted(tree)
    // Not necessary for box presentation.
    levels(tree, 0, 0)
    leaves(tree)
    var bigbox = [1189, 1682]
    if(target == '9681') {
        bigbox = [400,200]
        BB = 10
    }
    if(target == '39107') {
        bigbox = [400,280]
    }
    boxes(tree, bigbox[0], bigbox[1])
    // treedraw(tree)
    boxdraw(tree)
    $('path.Equus').css('fill', 'url(#zebra)')
    $('path.Leopardus').css('fill', 'url(#ocelot)')
    $('path.Giraffa').css('fill', 'url(#giraffe)')
    $('path.order').css('stroke-width', '2').css('stroke', 'black')
    // $('svg').draggable()
    $('.interior').mouseenter(function(){
      console.log(seekName($(this).attr('taxid')))
    })
}

stripINT = function(t)
{
    t.name = t.name.replace(/^INT/,'')
    if(!t.children) {
        return t
    }
    $(t.children).each(function(i,c){
        stripINT(c)
    })
    return t
}

// Remove the nodes in t that have no name, and those whose
// name contains 'environmental samples'.
remove_unwanted = function(t)
{
    var id = t.name.replace(/^INT/,'')
    if(!ncbiname[id] ||
      ncbiname[id].scientific.match(/environmental +samples/))
    {
        return null
    }
    if(!t.children) {
        return t
    }
    var children = []
    $(t.children).each(function(i,c){
        var r = remove_unwanted(c)
        if(r) {
            children.push(r)
        }
    })
    delete t.children
    if(children.length) {
        t.children = children
    }
    return t
}

// Annotate tree *t* by counting number of leaves
// underneath each node.  .leaves attribute is modified.
leaves = function(t) {
    if(!t.children) {
        t.leaves = 1
        return t
    }
    var l = 0;
    $(t.children).each(function(i, c){
      leaves(c)
      l += c.leaves
    })
    t.leaves = l
    return t
}
// Allocate width and height for a box for each node in the tree.
// A node's box nests all of its children's boxes.
// Sibling boxes do not overlap.
// Each node has a .size attribute written to it, where .size =
// [ width, height ].
// Old-style divided each box equally amongst the children.
// Which actually looks kinda cool.
// Current algorithm divides each box in proportion to the
// number of leaves under each child.
// :todo: assign x,y in this function too.
boxes = function(t, w /* width */, h /* height */)
{
    var minsize = 10; // Minimum width or height for a box.
    if(!t.children) {
        w = Math.max(minsize, w)
        h = Math.max(minsize, h)
        t.size = [w, h]
        return
    }
    var axis;
    if(w>=h) {
        t.layout = 'horiz'
        axis = 0
    } else {
        t.layout = 'vert'
        axis = 1
    }
    if(!split1(t, axis, [w,h])) {
        var m = 2;
        var layout = t.layout
        var res;
        do {
            t.layout = m + layout
            res = splitm(t, m, axis, [w,h])
            ++m
        } while(!res && m <= 4)
        if(!res) {
          console.log(t.name, "not enough "+['horiz','vert'][axis])
          t.outofspace = true
        }
        t.size = [w,h]
    } else {
        // Allow box to stretch in the other dimension to *axis*.
        // Slightly nasty in that it just assumes 2 axes.
        var maxd = Array.max(t.children.map(function(x){
            return x.size[1-axis]}))
        t.size = [maxd + 2*BB, maxd + 2*BB]
        t.size[axis] = [w,h][axis]
    }
}

// Split the box along a single axis, allocating space for each
// child (in t.children). *dimension* gives the size of
// the box, [w,h].  After returning, each element of t.children
// will have a .size attribute.  Returns true if there was
// enough space, but false if there was not enough space.
split1 = function(t, axis, dimension)
{
    // Sort children in increasing order (of leaf count).
    var sl = t.children.concat().sort(function(a,b){
        return a.leaves - b.leaves;
    })
    return split1list(t, sl, axis, dimension)
}
// Split the box into *m*, with cuts parallel to *axis*, then split
// again to allocate space for the children.
// We use 'row' in this function to mean the sequence parellel
// to *axis*, which may be either vertical or horizontal.  There
// are *m* rows.
splitm = function(t, m, axis, dimension)
{
    // *n* leaves in each of *m* rows.
    var n = Math.ceil(t.leaves/m)
    var j;
    var res = true;
    // Allocate space for each 'row'.  Tricky.
    var dim = dimension.slice()
    dim[1-axis] = (dimension[1-axis]-(m+1)*BB)/m + 2*BB
    // Index into t.children array.
    var i = 0;
    for(j=0; m>j; ++j) {
        // Count, so far, of leaves in this row.
        var c = 0;
        var rowstart = i;
        do {
            c += t.children[i].leaves
            ++i
        } while(i < t.children.length && c < n)
        // :todo: when c > n, consider whether to put
        // last child in this row or next row.
        var sl = t.children.slice(rowstart, i)
        while(sl.length < n) {
            // fake child to insert a blank space
            sl = sl.concat([{leaves:1, fake:true}])
        }
        if(!split1list(t, sl, axis, dim)) {
            res = false
        }
    }
    return res
}
split1list = function(t, inorder, axis, dimension)
{
    var leaves = inorder.reduce(function(a,b){
        return a+b.leaves}, 0)
    var space;
    var n = inorder.length;

    // Split along axis *axis* (0: horizontal, 1: vertical).
    space = dimension[axis] - (n+1)*BB
    $(inorder).each(function(i,c){
        if(c.fake) {
            // fake child; insert blank space
            return
        }
        var some = c.leaves/leaves * space
        var childbox = dimension.slice()
        $(childbox).each(function(i,d) {
            if(i == axis) {
                childbox[i] = some
            } else {
                childbox[i] -= 2*BB
            }
        })
        boxes(c, childbox[0], childbox[1])
        space -= c.size[axis]
        leaves -= c.leaves
    })
    if(0 > space) {
        return false
    }
    return true
}

// Return node with name.
search = function(t, name) {
    if(t.name == name) {
        return t
    }
    if(!t.children) {
        return null
    }
    var i
    for(i in t.children) {
        var c = t.children[i]
        var r = search(c, name)
        if(r) {
            return r
        }
    }
    return null
}
// lookup name from taxid.
seekName = function(id) {
    var n;
    var r;
    if(id.match(/^INT/)) {
        id = id.slice(3)
    }
    // 2204
    n = ncbiname[id]
    if(!n) {
        r = 'Noname taxid ' + id
    } else if(n.genbank) {
        r = n.genbank
    } else if(n.common) {
        r = n.common
    } else if(n.scientific) {
        if(n.scientific.match(/environmental +samples/)) {
            console.log('environmental samples', id)
        }
        r = n.scientific
    }
    if(!r) {
        r = 'Noname taxid ' + id
    }
    // r = r.replace(/^unclassified/, '\u2316')
    r = r.replace(/^unclassified/, '?')
    if(extinct[id]) {
        // There Does Not Exist (funny, but looks bad)
        // r = '\u2204 ' + r
        // Black Diamond Minus White X
        r = '\u2756 ' + r
    }
    return r
}

// Recursive descent on tree to compute .level (distance from
// root) for all nodes, and .count for leaf nodes (the ordinal
// sequence in left-to-right traversal.
function levels(t, level, leaves) {
    t.level = level;
    if(!t.children) {
        t.count = leaves
        return leaves + 1
    }
    $.each(t.children, function(i,c) {
        leaves = levels(c, level+1, leaves)
    })
    return leaves
}
// Recursive Descent drawing.
function treedraw(t, cx, cy) {
    var $port = $('.port');
    var style = $port.attr('drawstyle');
    style = style || 'star';

    t.x = t.level * 50
    if(t.count !== undefined) {
        t.y = t.count * 16 + 10
        var text = svg('text', {
          class: 'leaf',
          x: t.x,
          y: t.y,
        })
        $(text).append(seekName(t.name))
        $('.port').append(text)
        return
    }
    var sy = 0;
    $.each(t.children, function(i,c) {
        treedraw(c)
        sy += c.y
    })
    // y co-ord of interior node is average of children.
    t.y = sy/t.children.length
    $.each(t.children, function(i,c) {
        var d;
        // Star branching style.
        d = 'M'+t.x+' '+t.y+'L'+c.x+' '+c.y;
        if(style=='butt') {
            // Square butt style.  Horizontal spur.
            d = 'M'+t.x+' '+c.y+'H'+c.x;
        }
        var path = svg('path', {
          'd': d})
        $('.port').append(path)
    })
    // Square butt style.  Vertical support.
    if(style=='butt') {
        var last = t.children.length - 1;
        var ymin = t.children[0].y
        var ymax = t.children[last].y
        var d = 'M'+t.x+' '+ymin+'V'+ymax;
        var path = svg('path', {
          'class': 'interior',
          'taxid': t.name,
          'd': d})
        $('.port').append(path)
        var text = $(svg('text',
          {class:'interior', x:0,y:-2})).append(seekName(t.name))
        var g = svg('g',
          { 'transform':
            'translate('+t.x+' '+(ymin+ymax)/2+') rotate(-90)' })
        $(g).append(text)
        $('.port').append(g)
    }
}
// Draw the tree *t* box style, in the element specified by
// selector.  The element is emptied first.
boxdraw = function(t, selector)
{
    selector = selector || '.port';
    $(selector).empty();
    return boxdrawr(t, selector, 0, 0)
}
boxdrawr = function(t, selector, x, y) {
    var w = t.size[0];
    var h = t.size[1];
    var d = 'M'+x+' '+y+'v'+h+'h'+w+'V'+y+'z';
    var path;
    var class_ = seekName(t.name);
    if(t.outofspace) {
        class_ += ' outofspace'
    }
    if(rank[t.name]) {
        class_ += ' ' + rank[t.name]
    }
    path = svg('path', {class:class_, d:d, taxid:t.name})
    t.x = x
    t.y = y
    $(selector).append(path)
    if(!t.children) {
        labelBox(t)
        return
    }
    x += BB;
    y += BB;
    var p = [x,y]
    var origin = [x,y];
    var n = t.children.length
    var axis
    if(t.layout.match(/horiz/)) {
        axis = 0;
    } else {
        axis = 1;
    }
    var m = t.layout.match(/^\d+/)
    var nrows = 1
    if(m) {
        nrows = +m[0]
    }
    var rowlen = Math.ceil(n/nrows)
    $(t.children).each(function(i,c){
        boxdrawr(c, selector, p[0], p[1])
        p[axis] += c.size[axis] + BB
        if(Math.floor(i/rowlen) != Math.floor((i+1)/rowlen)) {
            p[axis] = origin[axis]
            p[1-axis] += c.size[1-axis] + BB
        }
    })
}

labelBox = function(t)
{
    var text;
    var w,h;
    w = t.size[0]
    h = t.size[1]
    var name = seekName(t.name);
    if(h >= 10 && w >= 30) {
        text = svg('text',
            { class: 'leaf', x:t.x+1, y:t.y+h-2} )
    } else if(h >= 20 && w >= 10) {
        text = svg('text',
            { class: 'leaf',
              transform: 'translate('+(t.x+w-2)+','+(t.y+h-1)+
                ') rotate(-90)',
              x:0, y:0 })
    }
    if(text) {
        $(text).append(name)
        $('.port').append(text)
    }
}

// Create DOM element in SVG namespace
function svg(tag, attr) {
    var el;
    el = document.createElementNS('http://www.w3.org/2000/svg', tag);
    if(attr) {
        $.each(attr, function(k,v){
            el.setAttribute(k, v)
        })
    }
    return el;
}
})
</script>
</head>
<body>
<div class="paint">
<svg height='20000px' width='1800px'
  xmlns:xlink="http://www.w3.org/1999/xlink"
>
<defs>
  <pattern id="zebra" width='228' height='206'
    patternUnits='userSpaceOnUse'
    patternTransform='scale(0.5)'
  >
    <image
      xlink:href="zebracrop.jpg"
      width='228'
      height='206'
    />
  </pattern>
  <pattern id="ocelot" width='246' height='208'
    patternUnits='userSpaceOnUse'
    patternTransform='scale(0.5)'
  >
    <image
      xlink:href="ocelotcrop.jpg"
      width='246'
      height='208'
    />
  </pattern>
  <pattern id="giraffe" width='141' height='105'
    patternUnits='userSpaceOnUse'
    patternTransform='scale(0.5)'
  >
    <image
      xlink:href="giraffecrop.jpg"
      width='141'
      height='105'
    />
  </pattern>
</defs>
<g class='port' drawstyle='butt'
  stroke='olive' fill='none' transform='translate(0.5,0.5)'>
</g>
</svg>
</div>
<div class="log"></div>
</body>
